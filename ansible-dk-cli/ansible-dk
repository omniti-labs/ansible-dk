#!/opt/ansible-dk/embedded/bin/python
#
# TODO: this code is very *nix centric.  Ensure that this works with Windows systems

import click
import os
import sys
import json
import yaml
from tempfile import NamedTemporaryFile
from ansible.executor import playbook_executor
from ansible.inventory import Inventory
from ansible.parsing.dataloader import DataLoader
from ansible.vars import VariableManager
from collections import namedtuple

###################################################
# Defaults
RUBY_ABI = "2.1.0"
PYTHON_ABI = "2.7"
HOME = os.getenv("HOME")

def get_config(debug=False):
    #TODO: pass debug properly
    config_path=os.path.expanduser('~/.ansible-dk/config')
    #TODO: absolute path for default generator repo
    config = {
        'generator': {
            'repo': 'generators/'
        }
    }
    if os.path.isfile(config_path):
        try:
            config.update(yaml.load(open(config_path, 'r')))
            if debug:
                click.echo("Loaded config from %s:\n%s" % (config_path, config))
            return config
        except:
            if debug:
                click.echo("Error loading config file %s" % config_path)
            return config
    else:
        if debug:
            click.echo("No config file found at %s" % config_path)
        return config

# pull version from version-manifest file left by package install
def check_version():
    file='/opt/ansible-dk/version-manifest.json'
    try:
        version = json.loads(open(file).read())['build_version']
    except ValueError as e:
        print "%s in %s" % (e, file)
        sys.exit(-1)
    except KeyError as e:
        print "Could not find %s in %s" % (e, file)
        sys.exit(-1)
    except (IOError, OSError) as e:
        message = "Error checking version: %s" % e.strerror
        if type(e.filename) == str:
            message += " %s" % e.filename
        print(message)
        sys.exit(e.errno)
    return version

###################################################
# Generic top-level group definition
@click.group()
@click.version_option(version=check_version())
def cli():
    pass

###################################################
# shell-init command
@cli.command(name='shell-init')
@click.option('--debug', is_flag=True, help="Enable debug mode")
@click.argument('shell', default='bash')
# TODO: Currently shell argument doesn't actually do anything.  Implement other shells, zsh anyone?
def shell_init(shell, debug=False):
    if debug:
        print("[DEBUG] Home directory = %s" % HOME)

    directories = [
        HOME+"/.ansible-dk",
        HOME+"/.ansible-dk/gem",
        HOME+"/.ansible-dk/python"
    ]

    for directory in directories:
        try:
            if debug:
                print("[DEBUG] Creating directory: %s" % directory)
            os.mkdir(directory)
        except OSError as e:
            if e.errno == 17: # if file exists
                if debug:
                    print("[DEBUG] %s - skipping - %s" % (e.strerror, e.filename))
                pass
            else:
                print("Error creating %s - %s(%d)" % (e.filename, e.strerror, e.errno))
                sys.exit(e.errno)

    # Print out environment variables for the shell
    print("export PATH=\"/opt/ansible-dk/bin:"+HOME+"/.ansible-dk/python/bin:"+HOME+"/.ansible-dk/gem/ruby/"+RUBY_ABI+ \
          "/bin:/opt/ansible-dk/embedded/bin:$PATH\"")
    print("export GEM_ROOT=\"/opt/ansible-dk/embedded/lib/ruby/gems/"+RUBY_ABI+"\"")
    print("export GEM_HOME=\""+HOME+"/.ansible-dk/gem/ruby/"+RUBY_ABI+"\"")
    print("export GEM_PATH=\""+HOME+"/.ansible-dk/gem/ruby/"+RUBY_ABI+ \
          ":/opt/ansible-dk/embedded/lib/ruby/gems/"+RUBY_ABI+"\"")
    print("export PYTHONUSERBASE=\""+HOME+"/.ansible-dk/python\"")
    print("export PIP_INSTALL_OPTION=\"--user\"")

###################################################
# verify command
@cli.command()
def verify():
    commands = [
        'ansible-dk --version',
        'aws --version 2>&1 | tr " " "\n" | tr "/" " "',
        'ansible --version',
        'ansible-lint --version',
        'ruby --version',
        'kitchen --version',
        'gem list ^kitchen-* serverspec | tail -n+0',
        'jq --version'
    ]
    for command in commands:
        if os.system(command) != 0:
            print "Verification of %s failed." % command.split()[0]
            sys.exit(-1)
    print "Verification succeeded."

###################################################
# generate command
@cli.group()
def generate():
    pass

_generator_options = [
    click.option('--debug', is_flag=True, help="Enable debug mode"),
    click.option('--generator', '-g', default=get_config()['generator'], help='Path to custom generator repo'),
    click.argument('name')
]
def generator_options(fn):
    for option in _generator_options:
        fn = option(fn)
    return fn

#TODO: generate these dynamically
@generate.command(name='repo')
@generator_options
def generate_repo(debug, generator, name):
    playbook_path = generator + '/repo.yml'
    if debug:
        click.echo('generating repo using %s' % playbook_path)
    run_ansible(playbook_path, {'repo_name': name})

@generate.command(name='role')
@generator_options
def generate_role(debug, generator, name):
    playbook_path = generator + '/role.yml'
    if debug:
        click.echo('generating role using %s' % playbook_path)
    run_ansible(playbook_path, {'role_name': name})

@generate.command(name='filter')
@generator_options
def generate_filter(debug, generator, name):
    playbook_path = generator + '/filter.yml'
    if debug:
        click.echo('generating filter using %s' % playbook_path)
    run_ansible(playbook_path, {'filter_name': name})

@generate.command(name='inventory')
@generator_options
def generate_inventory(debug, generator, name):
    playbook_path = generator + '/inventory.yml'
    if debug:
        click.echo('generating inventory using %s' % playbook_path)
    run_ansible(playbook_path, {'inventory_name': name})

@generate.command(name='config')
@generator_options
def generate_config(debug, generator, name):
    playbook_path = generator + '/config.yml'
    if debug:
        click.echo('generating config using %s' % playbook_path)
    run_ansible(playbook_path, {'config_name': name})

@generate.command(name='playbook')
@generator_options
def generate_playbook(debug, generator, name):
    playbook_path = generator + '/playbook.yml'
    if debug:
        click.echo('generating playbook using %s' % playbook_path)
    run_ansible(playbook_path, {'playbook_name': name})

def run_ansible(playbook, vars=None):
    if not os.path.exists(playbook):
        print 'Error - specified role generator playbook does not exist'
        sys.exit()
    Options = namedtuple('Options', ['connection', 'module_path', 'forks', 'become', 'become_method', 'become_user', 'check', 'listhosts', 'listtasks', 'listtags', 'syntax', 'remote_user', 'private_key_file', 'ssh_common_args', 'sftp_extra_args', 'scp_extra_args', 'ssh_extra_args', 'verbosity'])
    options = Options(connection='local', module_path=None, forks=100, become=None, become_method=None, become_user=None, check=False, listhosts=False, listtasks=False, listtags=False, syntax=False, remote_user=None, private_key_file=None, ssh_common_args=None, sftp_extra_args=None, scp_extra_args=None, ssh_extra_args=None, verbosity=None)
    loader = DataLoader()
    variable_manager = VariableManager()
    inventory = Inventory(loader=loader, variable_manager=variable_manager, host_list='localhost')
    variable_manager.set_inventory(inventory)
    if vars:
        variable_manager.extra_vars = vars
    playbook_executor.PlaybookExecutor(
        playbooks=[playbook],
        inventory=inventory,
        options=options,
        loader=loader,
        variable_manager=variable_manager,
        passwords=dict()
    ).run()

###################################################
# Call main CLI
if __name__ == '__main__':
    cli()
